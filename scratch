Int :: a : 1
 0b1010 => 10
 0o12 => 10
 0xFF ==> 255
List ? :: b : {1, 2, 3}
 b.0 ==> 1
 b.[1+1] ==> 3
 b.[{0,2}] ==> 1, 3
 b.{0..2} ==> 1, 2, 3
 #b ==> 3
 {1 2} ==> 1, 2 ?
 {} ==> {}
String :: c : 'asd'
 c.1 ==> 's'
 #c ==> 3
Float :: d : 0.01
Bool :: e : true
Fun :: f : [ 'statement' ]
 f ==> 'statement'
 [[]] ==> [] ==> null?
 pow : a, b >> [ a**b ]
Dict|Map :: g : { x : 1, y : 0, z : 0 }
{1 : "one", 2 : "two", * : "other"}
m.'two'

{1, 2} ~ {3, 4} ==> {1, 2, 3, 4}
'hold' ~ 'on' ==> 'holdon'

EntryPoint : [ List :: args |
    stdout 'Hello world!\n'
    0
]

fib : [ n | if [n < 2] [n] [(n-1 >> fib) + (n-2 >> fib)]]
fib : [ n | { true : n, false : (n-1 >> fib) + (n-2 >> fib) }.(n < 2) ]
fib : [ n | (n < 2) >> { true : n, false : (n-1 >> fib) + (n-2 >> fib) } ]

`+ 1 1 ==> 2
$elf
^ @ & \ ! (unused symbols)

=  <>  +  -  *  /  % (modulo)  ** (exp)  // (nth root)
bit-and  bit-or  bit-xor  bit-not  bit-rshift  bit-lshift  and  or  not

sprintf << 'hello %s' << 'world'
"hello %s" << 'world'

123 >> {pattern matching}

Grammar :: if _ then _ : [ Expr :: a, Expr :: b | (true : b, false : []).a ]
Grammar :: if _ then _ : [ Fun :: a, Fun :: b | (true : b, false : []).a ]
Grammar :: if _ then _ else _ : [ a, b, c | (true : b, false : c).a ]
if [1 = 1] then [stdout "hallo"]

Grammar :: _ ** _ : [ a, b | 0 = b >> (true : 1, false : a * $(a, b-1)) ]
Grammar :: _ ** _ : [ a, b | if [b > 1] then [a * $(a,b-1)] else [a] ]
Grammar :: _ ** _ : [ a, b | b > 1 >> (true : [a * $(a,b-1)], false : [a]) ]

Grammar :: while _ repeat _ :: [ a, b | if a then [b; $(a,b)] ]
-- higher-order functions
map  fold  filter  group?

2 >> [a|a*a] >> stdout
2 >> [?*?] >> stdout
stdout [a,b|a*b](2,3)

Fun :: f : [a|a+1]
1 >> f ==> 2
f(1) ==> 2
f ==> f
---
multiline comment
---
1-1 -- single line comment

(2,3) >> [a,b|a*b] >> stdout
stdout [a,b|a*b](2,3)
stdout [a,b|a*b][2,3]

stdout [a,b|a*b] [a|a,a+2] [2]
stdout (2,3) >> [a,b|a*b]
(2,3) >> [a,b|a*b] >> stdout

f(g(),h(i(),j(k()),l()),m(n()))
(f
 (g)
 (h
  (i)
  (j
   (k))
  (l))
 (m
  (n)))
f << (g (h << i (j << k) l) (m << n))
f << (g (h << i (j << k) l) (m << n))

[n|[f|n>>f]] << 2 << [n|n*n]
[f|2>>f] << [n|n*n]
(2>>[n|n*n])
(2*2)

((λnm.m-n) 1) (((λnf.f n) 2) λn.n*n)
([n|[m|m-n]] << 1) << ([n|[f|f<<n]] << 2 << [n|n*n])
([n|[m|m-n]] @ 1) @ ([n|[f|f@n]] @ 2 @ [n|n*n])

[n|[f|f<<n]] << 2 << [n|n*n] >> ([n|[m|m-n]] << 1)
[n|[m|m-n]] << 1 <<< [n|[f|f<<n]] << 2 << [n|n*n]
[n|[m|m-n]](1)([n|[f|f<<n]](2)([n|n*n]))
([n|[m|m-n]] @ 1) @ ([n|[f|f@n]] @ 2 @ [n|n*n])
a << b << c <<< d << e <<< f << g << h <<<< i << j << k <<< l << m << n
((a << b << c) <<< (d << e) <<< (f << g << h)) <<<< ((i << j << k) <<< (l << m << n))
(((a(b(c())))(d(e())))(f(g(h()))))((i(j(k())))(l(m(n))))
a<<b<<c<<<d<<e<<<f<<g<<h<<<<i<<j<<k<<<l<<m<<n
a@b@c@@d@e@@f@g@h@@@i@j@k@@l@m@n

a << b << c
<<< d << e
<<< f << g << h
<<<< i << j << k
<<< l << m << n

((lambda (n) (lambda (n) (- m n))) 1)
[n|[m|m-n]]<<1  ==>  [m|m-1]
(λn.λm.m-n) 1
(λnm.m-n) 1  ==>  λm.m-1

printf << "Hello %s", "world!\n"
printf << "%s %s\n" << (sprintf << "%i", 2 - 1), "is a number";

f:[a,b|a*b]
==> function
f@2,2-1
==> 3
f{2,2-1}
==> 2

